project temp

-- test component --
component test
{
	uint32 val
	bool another

}

component another
{
	Entity thing
}

arch testable with test
{
	function foo(uint32 A uint32 B)
	{
		return A + B

		--
		ByteCode:

		PushScope        ; Push the scope for the function
		CreateVariable B ; store the last input as a variable named B
		CreateVariable A ; store the next input as a variable named A

		PushVariable A   ; push the value of A into the output
		PushVariable B   ; push the value of B into the output
		FlipIO           ; Flip the values of A and B into the input
		OperatorAdd      ; Add the values of A and B and push the result ino output

		FlipIO           ; Flip the result of the addition into the input before returning
		PopScope         ; pop the scope nullifying variables A and B
		--
	}
}

interface ITest requires test
{
	function foo(uint32 in) -> void;
	function another;
	function temp -> uint32;
}

system testSystem extends testable
{
	
}

entity entt with another extends testable 
using testSystem 
impl ITest
{
	construct(uint32 in)
	{
		
	}

	construct()
	{
		
	}

	impl function foo(uitn32 in) -> void from ITest
	{
		
	}
}